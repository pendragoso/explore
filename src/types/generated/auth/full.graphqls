directive @secured(req: String!, err: String) on OBJECT | FIELD_DEFINITION | INPUT_OBJECT | VARIABLE_DEFINITION
""" This can be removed once we update to Federation 2. It is just a placeholder so we don't forget to add the directive on the necessary objects and mutations.
"""
directive @inaccessible on OBJECT | FIELD_DEFINITION | INPUT_OBJECT
directive @connection on OBJECT
directive @extends on OBJECT | INTERFACE
directive @external on FIELD_DEFINITION
directive @key(fields: _FieldSet!) on OBJECT | INTERFACE
directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
enum CountryCode {
AD
AE
AF
AG
AI
AL
AM
AO
AQ
AR
AS
AT
AU
AW
AX
AZ
BA
BB
BD
BE
BF
BG
BH
BI
BJ
BL
BM
BN
BO
BQ
BR
BS
BT
BV
BW
BY
BZ
CA
CC
CD
CF
CG
CH
CI
CK
CL
CM
CN
CO
CR
CU
CV
CW
CX
CY
CZ
DE
DJ
DK
DM
DO
DZ
EC
EE
EG
EH
ER
ES
ET
FI
FJ
FK
FM
FO
FR
GA
GB
GD
GE
GF
GG
GH
GI
GL
GM
GN
GP
GQ
GR
GS
GT
GU
GW
GY
HK
HM
HN
HR
HT
HU
IC
ID
IE
IL
IM
IN
IO
IQ
IR
IS
IT
JE
JM
JO
JP
KE
KG
KH
KI
KM
KN
KP
KR
KW
KY
KZ
LA
LB
LC
LI
LK
LR
LS
LT
LU
LV
LY
MA
MC
MD
ME
MF
MG
MH
MK
ML
MM
MN
MO
MP
MQ
MR
MS
MT
MU
MV
MW
MX
MY
MZ
NA
NC
NE
NF
NG
NI
NL
NO
NP
NR
NU
NZ
OM
PA
PE
PF
PG
PH
PK
PL
PM
PN
PR
PS
PT
PW
PY
QA
RE
RO
RS
RU
RW
SA
SB
SC
SD
SE
SG
SH
SI
SJ
SK
SL
SM
SN
SO
SR
SS
ST
SV
SX
SY
SZ
TC
TD
TF
TG
TH
TJ
TK
TL
TM
TN
TO
TR
TT
TV
TW
TZ
UA
UG
UM
US
UY
UZ
VA
VC
VE
VG
VI
VN
VU
WF
WS
YE
YT
ZA
ZM
ZW
}
""" input schemas"""
input CreateCredentialInput {
name: String
mode: Mode!
organization: String!
expiredAt: DateTime
roles: [String!]
assignableRoles: [String]
type: CredentialType!
user: String
}
""" schemas"""
type Credential {
id: ID!
createdAt: DateTime!
createdBy: ID!
expiredAt: String
lastUsedAt: String
mode: Mode!
name: String
organization: ID!
user: User
multiFactorAuthenticated: MultiFactorAuthenticated
roles: [ID!]
assignableRoles: [ID]
type: CredentialType
updatedAt: DateTime!
updatedBy: ID!
}
type CredentialConnection {
edges: [CredentialEdge]
pageInfo: PageInfo
}
type CredentialEdge {
cursor: String
node: Credential
}
input CredentialFilter {
type: CredentialType
user: ID
expiredAtBefore: DateTime
expiredAtAfter: DateTime
}
""" schemas"""
type CredentialServiceToken {
id: ID
credential: Credential
organization: String
mode: Mode
storeId: Int
serviceToken: String
}
""" input schemas"""
input CredentialServiceTokenCreateInput {
storeId: Int!
}
input CredentialServiceTokenQueryInput {
storeId: Int!
mode: Mode!
}
type CredentialSession {
id: ID!
createdAt: DateTime!
validUntil: DateTime
credential: ID!
organization: ID!
serviceToken: String
user: ID
store: Int
""" list of permission name"""
permissions: [String!]
mode: Mode!
}
enum CredentialType {
API_TOKEN
USER_TOKEN
HELLO_TOKEN
SERVICE_TOKEN
}
input CredentialUpdateInput {
id: ID!
name: String
expiredAt: DateTime
roles: [String!]
assignableRoles: [String]
}
enum CurrencyCode {
AED
AFN
ALL
AMD
ANG
AOA
ARS
AUD
AWG
AZN
BAM
BBD
BDT
BGN
BHD
BIF
BMD
BND
BOB
BRL
BSD
BTC
BTN
BWP
BYN
BYR
BZD
CAD
CDF
CHF
CLF
CLP
CNY
COP
CRC
CUC
CUP
CVE
CZK
DJF
DKK
DOP
DZD
EGP
ERN
ETB
EUR
FJD
FKP
GBP
GEL
GGP
GHS
GIP
GMD
GNF
GTQ
GYD
HKD
HNL
HRK
HTG
HUF
IDR
ILS
IMP
INR
IQD
IRR
ISK
JEP
JMD
JOD
JPY
KES
KGS
KHR
KMF
KPW
KRW
KWD
KYD
KZT
LAK
LBP
LKR
LRD
LSL
LTL
LVL
LYD
MAD
MDL
MGA
MKD
MMK
MNT
MOP
MRO
MUR
MVR
MWK
MXN
MYR
MZN
NAD
NGN
NIO
NOK
NPR
NZD
OMR
PAB
PEN
PGK
PHP
PKR
PLN
PYG
QAR
RON
RSD
RUB
RWF
SAR
SBD
SCR
SDG
SEK
SGD
SHP
SLL
SOS
SRD
STD
SVC
SYP
SZL
THB
TJS
TMT
TND
TOP
TRY
TTD
TWD
TZS
UAH
UGX
USD
UYU
UZS
VEF
VND
VUV
WST
XAF
XAG
XAU
XCD
XDR
XOF
XPF
YER
ZAR
ZMW
ZWL
ZMK
}
"""An RFC-3339 compliant DateTime Scalar"""
scalar DateTime
"""java.math.BigDecimal"""
scalar Decimal
enum ErrorDetail {
"""
Unknown error.
This error should only be returned when no other error detail applies.
If a client sees an unknown errorDetail, it will be interpreted as UNKNOWN.
HTTP Mapping: 500 Internal Server Error
"""
UNKNOWN
"""
The requested field is not found in the schema.
This differs from `NOT_FOUND` in that `NOT_FOUND` should be used when a
query is valid, but is unable to return a result (if, for example, a
specific video id doesn't exist). `FIELD_NOT_FOUND` is intended to be
returned by the server to signify that the requested field is not known to exist.
This may be returned in lieu of failing the entire query.
See also `PERMISSION_DENIED` for cases where the
requested field is invalid only for the given user or class of users.
HTTP Mapping: 404 Not Found
Error Type: BAD_REQUEST
"""
FIELD_NOT_FOUND
"""
The provided cursor is not valid.
The most common usage for this error is when a client is paginating
through a list that uses stateful cursors. In that case, the provided
cursor may be expired.
HTTP Mapping: 404 Not Found
Error Type: NOT_FOUND
"""
INVALID_CURSOR
"""
The operation is not implemented or is not currently supported/enabled.
HTTP Mapping: 501 Not Implemented
Error Type: BAD_REQUEST
"""
UNIMPLEMENTED
"""
The client specified an invalid argument.
Note that this differs from `FAILED_PRECONDITION`.
`INVALID_ARGUMENT` indicates arguments that are problematic
regardless of the state of the system (e.g., a malformed file name).
HTTP Mapping: 400 Bad Request
Error Type: BAD_REQUEST
"""
INVALID_ARGUMENT
"""
The deadline expired before the operation could complete.
For operations that change the state of the system, this error
may be returned even if the operation has completed successfully.
For example, a successful response from a server could have been
delayed long enough for the deadline to expire.
HTTP Mapping: 504 Gateway Timeout
Error Type: UNAVAILABLE
"""
DEADLINE_EXCEEDED
"""
Service Error.
There is a problem with an upstream service.
This may be returned if a gateway receives an unknown error from a service
or if a service is unreachable.
If a request times out which waiting on a response from a service,
`DEADLINE_EXCEEDED` may be returned instead.
If a service returns a more specific error Type, the specific error Type may
be returned instead.
HTTP Mapping: 502 Bad Gateway
Error Type: UNAVAILABLE
"""
SERVICE_ERROR
"""
Request throttled based on server CPU limits
HTTP Mapping: 503 Unavailable.
Error Type: UNAVAILABLE
"""
THROTTLED_CPU
"""
Request throttled based on server concurrency limits.
HTTP Mapping: 503 Unavailable
Error Type: UNAVAILABLE
"""
THROTTLED_CONCURRENCY
"""
The server detected that the client is exhibiting a behavior that
might be generating excessive load.
HTTP Mapping: 429 Too Many Requests or 420 Enhance Your Calm
Error Type: UNAVAILABLE
"""
ENHANCE_YOUR_CALM
"""
Request failed due to network errors.
HTTP Mapping: 503 Unavailable
Error Type: UNAVAILABLE
"""
TCP_FAILURE
"""
Unable to perform operation because a required resource is missing.
Example: Client is attempting to refresh a list, but the specified
list is expired. This requires an action by the client to get a new list.
If the user is simply trying GET a resource that is not found,
use the NOT_FOUND error type. FAILED_PRECONDITION.MISSING_RESOURCE
is to be used particularly when the user is performing an operation
that requires a particular resource to exist.
HTTP Mapping: 400 Bad Request or 500 Internal Server Error
Error Type: FAILED_PRECONDITION
"""
MISSING_RESOURCE
}
enum ErrorType {
"""
Unknown error.
For example, this error may be returned when
an error code received from another address space belongs to
an error space that is not known in this address space.  Also
errors raised by APIs that do not return enough error information
may be converted to this error.
If a client sees an unknown errorType, it will be interpreted as UNKNOWN.
Unknown errors MUST NOT trigger any special behavior. These MAY be treated
by an implementation as being equivalent to INTERNAL.
When possible, a more specific error should be provided.
HTTP Mapping: 520 Unknown Error
"""
UNKNOWN
"""
Internal error.
An unexpected internal error was encountered. This means that some
invariants expected by the underlying system have been broken.
This error code is reserved for serious errors.
HTTP Mapping: 500 Internal Server Error
"""
INTERNAL
"""
The requested entity was not found.
This could apply to a resource that has never existed (e.g. bad resource id),
or a resource that no longer exists (e.g. cache expired.)
Note to server developers: if a request is denied for an entire class
of users, such as gradual feature rollout or undocumented allowlist,
`NOT_FOUND` may be used. If a request is denied for some users within
a class of users, such as user-based access control, `PERMISSION_DENIED`
must be used.
HTTP Mapping: 404 Not Found
"""
NOT_FOUND
"""
The request does not have valid authentication credentials.
This is intended to be returned only for routes that require
authentication.
HTTP Mapping: 401 Unauthorized
"""
UNAUTHENTICATED
"""
The caller does not have permission to execute the specified
operation.
`PERMISSION_DENIED` must not be used for rejections
caused by exhausting some resource or quota.
`PERMISSION_DENIED` must not be used if the caller
cannot be identified (use `UNAUTHENTICATED`
instead for those errors).
This error Type does not imply the
request is valid or the requested entity exists or satisfies
other pre-conditions.
HTTP Mapping: 403 Forbidden
"""
PERMISSION_DENIED
"""
Bad Request.
There is a problem with the request.
Retrying the same request is not likely to succeed.
An example would be a query or argument that cannot be deserialized.
HTTP Mapping: 400 Bad Request
"""
BAD_REQUEST
"""
Currently Unavailable.
The service is currently unavailable.  This is most likely a
transient condition, which can be corrected by retrying with
a backoff.
HTTP Mapping: 503 Unavailable
"""
UNAVAILABLE
"""
The operation was rejected because the system is not in a state
required for the operation's execution.  For example, the directory
to be deleted is non-empty, an rmdir operation is applied to
a non-directory, etc.
Service implementers can use the following guidelines to decide
between `FAILED_PRECONDITION` and `UNAVAILABLE`:
- Use `UNAVAILABLE` if the client can retry just the failing call.
- Use `FAILED_PRECONDITION` if the client should not retry until
the system state has been explicitly fixed.  E.g., if an "rmdir"
fails because the directory is non-empty, `FAILED_PRECONDITION`
should be returned since the client should not retry unless
the files are deleted from the directory.
HTTP Mapping: 400 Bad Request or 500 Internal Server Error
"""
FAILED_PRECONDITION
}
input MigrateCredentialServiceTokenInput {
storeId: Int!
email: String
organizationName: String!
}
enum Mode {
LIVE
TEST
}
enum MultiFactorAuthenticated {
IN_PROGRESS
VERIFIED
NOT_VERIFIED
}
enum MultiFactorAuthenticationMode {
SMS
SMS_NOT_VERIFIED
EMAIL
EMAIL_NOT_VERIFIED
NOT_VERIFIED
}
type Mutation {
userCreate(input: UserCreateInput!): User!
userUpdate(input: UserUpdateInput!): User!
""" normal password reset."""
userPasswordUpdate(email: String, currentPassword: String, newPassword: String): Result
login(input: UserLoginInput): CredentialSession
loginLegacy(input: UserLoginLegacyInput): CredentialSession
createCredential(createCredentialInput: CreateCredentialInput!): Credential!
credentialUpdate(input: CredentialUpdateInput!): Credential!
updateCredentialSessionContext(updateCredentialSessionInput: UpdateCredentialSessionInput!): CredentialSession!
validateCredential: CredentialSession
deleteCredential(id: ID!): Result
"""
When a subscription is created/turned on, we will assign all the given roles via this operation call, for all the respective organizations admin users as assignable roles
"""
credentialAddSubscriptionRoles(organizationIds: [ID!]!, roles: [ID!]!): Result
"""
When a subscription is no longer valid, we will remove all the given roles via this operation call, for all the respective organizations credentials
"""
credentialRemoveSubscriptionRoles(organizationIds: [ID!]!, roles: [ID!]!): Result
migrateCredentialServiceToken(input: MigrateCredentialServiceTokenInput): Result! @deprecated
"""
Create a link between one or more api token credentials and the organization service token.
"""
credentialServiceTokenCreate(input: CredentialServiceTokenCreateInput!): [CredentialServiceToken!]!
roleCreate(input: RoleCreateInput!): Role
roleUpdate(input: RoleUpdateInput!): Role
roleDelete(id: String): Result
roleGlobalCreate(input: RoleGlobalCreateInput): Role
roleValidateSlug(input: String!): Boolean
}
type PageInfo {
hasPreviousPage: Boolean!
hasNextPage: Boolean!
startCursor: String
endCursor: String
}
type Permission {
id: ID!
createdAt: DateTime!
description: String!
name: String!
}
type PermissionConnection {
edges: [PermissionEdge]
pageInfo: PageInfo
}
type PermissionEdge {
cursor: String
node: Permission
}
type Query {
permissions(first: Int = 10, after: String): PermissionConnection
credential(id: ID!): Credential
credentials(first: Int = 10, after: String, filter: CredentialFilter): CredentialConnection
getCredentialServiceToken(input: CredentialServiceTokenQueryInput): CredentialServiceToken
roles(first: Int = 10, after: String, filter: RoleFilter): RoleConnection
rolesGlobal(first: Int = 10, after: String, filter: RoleFilter): RoleConnection
users(first: Int = 10, after: String, filter: UserFilter): UserConnection
user(email: String): User
_service: _Service
}
enum Result {
SUCCESS
FAILURE
}
type Role {
id: ID!
createdAt: DateTime!
createdBy: ID!
description: String
name: String!
""" a unique name for your role. no space """
slug: String!
type: RoleType!
permissions: [String!]!
organization: ID
updatedAt: DateTime!
updatedBy: ID!
}
type RoleConnection {
edges: [RoleEdge]
pageInfo: PageInfo
}
input RoleCreateInput {
permissions: [String!]!
name: String!
slug: String!
description: String
}
type RoleEdge {
cursor: String
node: Role
}
input RoleFilter {
name: String
slug: String
type: RoleType
}
input RoleGlobalCreateInput {
permissions: [String!]!
name: String!
slug: String!
description: String
type: RoleType!
}
enum RoleType {
PUBLIC
INTERNAL
CUSTOM
SUBSCRIPTION
ORGANIZATIONAL
}
input RoleUpdateInput {
id: ID!
permissions: [String!]!
name: String!
description: String
}
type Ticket {
id: ID!
hash: String
userId: ID!
mfa: String
dateExpired: DateTime
}
input UpdateCredentialSessionInput {
organization: String
}
""" schemas"""
type User {
id: String!
createdAt: DateTime!
createdBy: ID!
email: String!
lastLoginAt: DateTime
multiFactorAuthentication: MultiFactorAuthenticationMode
multiFactorAuthenticationPhone: String
organizations: [ID!]!
status: UserStatus
updatedAt: DateTime!
updatedBy: ID!
}
type UserConnection {
edges: [UserEdge]
pageInfo: PageInfo
}
input UserCreateInput {
email: String!
password: String!
organizationIds: [ID!]!
multiFactorAuthenticationPhone: String
multiFactorAuthentication: MultiFactorAuthenticationMode
onBoarding: Boolean = false
}
type UserEdge {
cursor: String
node: User
}
input UserFilter {
userId: ID
email: String
status: UserStatus
}
""" input schemas"""
input UserLoginInput {
email: String!
password: String!
mode: Mode!
organizationId: ID
}
input UserLoginLegacyInput {
"""@deprecated"""
email: String
storeId: Int!
userToken: String!
}
enum UserStatus {
ACTIVE
DISABLED
}
input UserUpdateInput {
userId: ID!
organizationIds: [ID!]!
status: UserStatus!
}
"""java.time.ZonedDateTime"""
scalar ZonedDateTime
""""""
scalar _FieldSet
type _Service {
sdl: String!
}